---
title: Vue Interview Questions
stack: Vue Pinia
slug: vue3-pinia
date: 2024-06-01 00:00:00 +0000
---

## vue 的架构分析

## vue3 的整体架构

## vue3 构建过程

## 认识 diff 算法

## vue3 的编译器

## keep-alive 的作用

## 什么是调度器

## vue 调度系统的架构

## nexttick 的原理

## pinia 源码的调试

# vue3 相较于 vue2 引入了哪些主要的更新和改进

### composition API

- 解决 vue2 中 option API 的一些局限
- 允许开发者在功能逻辑上进行更好的组织和复用，使得代码在可读性，复用性和类型支持方面有显著提升
- 在复杂组件可以将逻辑代码拆分为更小的函数，有助于代码的维护和测试

### 性能优化

- 使用 proxy 的响应式系统，使得 vue3 能够高效的追踪数据的变化，并且支持对象和数组更深层次的监听
- vue3 的虚拟 DOM 和编译器也进行了优化，减少了不必要的渲染和重绘，提高了性能

### Tree-shaking

- vue3 是基于模块化的，并且更好的支持函数式开发，可以被打包工具更好的进行树摇优化
- 为使用的代码可以在打包时被移除，从而减少最终的文件大小，对于在性能和加载速度有要求的项目十分重要

### 更好的 typescript 支持

- vue3 在设计之初就考虑到了 ts 的支持，框架内部实现和 api 设计都与 ts 高度兼容
- 开发者可以方便 vue 项目中使用 ts，并且在开发过程中获得更好的类型推断和代码提示

### 新组件和特性

- fragments，teleport，suspense
- fragment 允许一个组件返回多个根节点，teleport 可以将组件渲染到 DOM 中的其他位置，suspense 提供了更好的异步加载体验，

### 改善的内部架构

- 重写了框架核心，使得更加模块化和轻量化，提高了性能，也为未来的扩展和维护提供了更好的基础
- 模块化的设计让开发者可以按需引入特性，而不是加载整个框架，从而优化项目的打包体积

# 是什么使得 vue3 在性能上比 vue2 更有优势

### 基于 proxy 的响应式系统

- object.defineProperty，无法检测到对象属性的添加和删除，也对数组的索引和长度变化有一定限制
- proxy 能够更能精确和高效的追踪对象和数组的所有变化。proxy 允许拦截所有操作
- 减少了 vue3 处理复杂数据结构的性能损耗，特别是在需要大量数据操作的应用中

### 编译器优化

- vue3 的编译器进行了全面优化，更加智能的生成渲染函数，引入了静态提升和 Block 等技术
- 静态提升： 指将不变的部分标记为静态节点，这样在后续的渲染中就不需要重复创建这些节点
- block 可以将动态的节点放到 dynamicchilld 中，在后续的 diff 算法中只需要比较动态节点

### 更小的打包的体积

- vue3 采用模块化设计，使得核心库和一些特性模块可以独立打包和按需加载
- 结合现代打包工具的树摇，可以去除未使用的代码，从而显著减少最终的打体积
- 更小的打包体积不仅减少了网络传输时间，还加快了浏览器的解析和执行速度，者对于首屏加载性能至关重要

### 优化的虚拟 DOM

- vue3 对虚拟 DOM 中的 diff 算法进行了改进，通过减少不必要的对比和重拍操作，使得渲染过程更加高效
- 引入了基于快的优化策略，可以将组件分成不同的渲染快，从而在更新时只需要更新变化的快，而不需要渲染整个组件

### 优化的依赖追踪

- vue3 在依赖追踪和更新做了更细粒度的优化
- 新的响应式系统可以更加精确的追踪依赖关系，只有在真正需要更新的时候才进行重新计算和渲染，避免了 vue2 中的某些不必要的重渲染问题

# vue3 中的 composition API 与 React hook 的异同

### 设计理念和语法差异

- vue3 是以函数的方式来组合和复用逻辑，提供了 setup 函数作为组件的入口点，允许开发者在一个函数中组织所有的逻辑，包块状态声明吗，声明周期钩子，以及方法定义
- hooks 时在现有函数组件基础上引入一组特殊的函数，用来在函数组件中管理状态和副作用
- 关键区别在于，compositionAPI 是 Vue 特有的 api 设计，允许将逻辑代码模块化，复用，并能清晰的管理依赖，hooks 则是通过将函数组件视为状态的宿主，来提供类似状态管理和生命周期的功能

### 响应式系统 vs 状态和副作用管理

- vue 中响应式是框架的核心概念，可以使用 ref 等 api 来创建响应式的数据对象，当这些数据发生变化时，视图会自动更新
- hooks 则是通过 usestate 管理状态，useEffect 处理副作用
- vue 的响应式系统是自动的，只要数据发生变化， 视图就会更新，而 hooks 则需要显示调用来更新状态和处理副作用，意味着在 vue 中不需要担心依赖管理的细节，react 需要在使用 useEffect 时指定依赖数组来控制副作用的执行

# 虚拟 DOM 是什么，为什么要使用虚拟 DOM

本质是一系列的 JavaScript 对象，组成树结构，用来映射真实的 DOM 树结构

为什么要使用虚拟 DOM

- 声明式开发
- 跨平台能力

# 虚拟 DOM 和真实 DOM 性能对比

理论上的性能对比

虚拟 dom 在性能和可维护之间找到平衡

# 虚拟 DOM 的解析过程是怎么样的

### createApp 传入组件

### 组件被解析成 render 函数

### render 函数返回一个 VNode

### VNode 经过 patchComponent

### VNode 经过 patchElememnt

### 最终的 DOM 操作

# DIff 算法的原理是什么，他是如何提高性能的

在没有 diff 算法的情况下，每当状态或者数据发生变化时，需要重新渲染整个页面的 DOM 树

- 每当数据发生变化，整个 DOM 树都会被移除，然后用新的内容重新构建和插入
- 非常耗时，还会导致页面的闪烁和不必要的重绘和重拍
- 对于大型和复杂的页面，每次重新构建 DOM 树的开销会随着节点数量的增加而显著增长，导致性能严重下降

diff 算法的工作

- 通过比较前后两个虚拟 DOM 树，来找出最小的差异，然后仅对这些差异部分进行更新，而不是渲染整个 DOM 树
- 每次状态更新时，框架会生成新的虚拟 DOM 树，框架将新的虚拟 DOM 与旧的虚拟 DOM 树进行比较，找出不同之处

提高性能

- 避免不必要的 DOM 更新
- 局部更新
- 更高效的节点处理
- 静态呢容优化

# vue3 的 diff 算法与 vue2 相比有什么改进

vue2 的 diff 算法主要采用的双端比较

- vue2 的 diff 算法会从头部和尾部开始比较新旧 VNode 列表，通过双端比较来找到需要移动或者更新的节点
- 先从头部对比，不匹配，再从尾部对比，最后处理中间部分

vue3 的 dff 算法的改进

- 块级优化
- 静态提升
- patchFlag 标记
- 更高效的 diff 算法，最长递增子序列

# vue 中 key 的作用是什么， 为什么要绑定

作用

- key 是一个特殊属性，用于标记虚拟 DOM 中的每个节点
- 帮助 vue 在 diff 算法中识别节点是否发生变化，或者节点是否需要被移动或者重用
- 没有 key，vue 会采用一种基于索引的方式来逐个对比新旧节点，导致不必要的 DOM 操作
- key 提供的唯一标识，使得 vue 能够更准确的识别和操作节点，从而减少不必要的 DOM 操作

为什么要绑定 key

- 主要原因提高 vue 中的 diff 算法性能
- key 允许 vue 精确定位每个节点，减少不必要的删除和创建操作

源码

没有 key，执行 patchUnkeyedChildren 方法

- vue 通过索引来比较新旧子节点
- 从头到尾逐个对比节点，如果节点不匹配，就会移除旧节点并创建新节点
- 在节点顺序发生变化时，导致不必要的重建和移除操作，影响性能

有 key，执行 patchKeyedChilidren 方法

- 从头部和尾部同步新旧节点，然后通过 key 进行快速定位
- 发现 key 匹配 的节点时，会将旧节点移动到新位置，或者插入新节点到正确的位置，避免不必要的 DOM 操作
- 通过 key，vue 可以在保证稳定序列的同时，优化节点的插入，删除，移动，确保最小的 DOM 操作次数

# 为什么不建议使用 index 作为 key

主要 key 的作用与 diff 算法的优化效果有关

- 当节点的顺序发生变化时，index 作为 key 会导致 vue 无法正确识别节点的变化
- key 应该时唯一且稳定的，可以正确识别每个节点，即使节点的顺序或者内容发生变化

# vue 中 Object.defineProperty 的缺点，以及 Proxy 的有点

缺点：

- 无法监听新增或者删除属性
- 无法监听数组的变化
- 劫持过程时递归的
- 设计初衷

proxy 优点

- 更加完善的对象拦截操作
- 数组支持
- 性能优化
- 灵活性和可扩展性
- 代码简化

# vue3 中的响应式系统是如何工程的

1. 创建响应式系统
2. 依赖收集
3. 副作用函数与 ReactiveEffect
4. 触发更新

# vue 在哪些情况下会进行依赖收集，机制是什么

依赖收集 的情况

1. 在响应式数据的读取操作时
2. 在组件渲染时
3. 在 watch 或者 computed 中读取响应式数据时

# vue 中的 watch 和 watchEffect 有什么不同

都是通过调用 dowatch 函数实现的

- 与 watch 不同，watchEffect 没有显示的数据源，也没有回调函数，efffect 函数会自动依赖执行过程中访问的所有响应式数据

watch 场景

- 精确控制数据变化的处理
- 获取新值和旧值
- 监听多个数据源

watchEffect 场景

- 自动依赖收集和副作用管理
- 简单的响应式副作用

# vue 中 reactive 和 ref 的区别，和它们使用场景

数据类型区别

- reactive 用于将对象转换为响应式对象的 API
- ref 是用于创建包含单一响应式值的对象，适用于基本数据类型

内部实现机制

- reactive 创建的响应式对象是通过 Proxy 进行全局代理的
- ref 创建的是包含单一值的对象，这个对象的 value 属性是响应式的

使用场景

- 需要处理嵌套的对象或者数组，并且希望整个对象的所有层级属性都能自动变为响应式时，使用 reactive
- 只需处理一个基本数据类型，ref 更合适

# vue 的双向绑定是如何工作的，简述基本原理

- 数据到视图
- 视图到数据

## 描述 vue 的模板编译过程

1. 解析
2. 转换
3. 代码生成

## vue3 在编译过程中进行了哪些优化，以提高运行时性能

- 静态提升
- patchFlag 优化
- Block 和 Dynamic CHildren
- 预字符串化静态内容
- 条件编译

# vue 中 template 和 jsx 的区别

template 优势

- 分离样式，结构，行为，代码具有可读性，易于理解
- 能够静态优化，提升性能

JSX

- 自由度
- 没法从编译层面进行优化
- 灵活

# 解释 keep-alive 组件的作用和实现机制

keep-alive 内部维护了一个缓存对象，这个对象存储了被包裹组件的虚拟节点

- 组件第一渲染，会被正常挂载到 DOM 中
- 当组件被切换出去时，keep-alive 并不会销毁他， 而是调用 deactivate 的方法，将组件从当前 DOM 中移除并放入一个隐藏容器中
- 当组件再次被激活时，keep-alive 会通过 activeate 将其从隐藏容器中取出，并重新挂载到 DOM 中

# nextTick 的原理时什么，有什么用

nextTick 方法的原理跟 vue 的调度系统有关

vue 的调度系统时通过任务队列来管理更新的，他会把数据变化触发的任务放到一个任务队列中，然后这些任务会被批量执行

nextTick 的作用是在下一个 DOM 更新循环结束之后执行一个回调函数

- 利用离 promise 的 then 方法
- vue 的更新任务已经在一个微任务队列中了， next Tick 时在这些更新任务完成后，再往微任务队列中插入一个 then 回调

## vue 中的数据对象属性变化时， 视图的更新是同步的还是异步的

- vue 采用了一个异步队列机制来管理视图更新
- vue 会在同一个时间循环结束前，批量执行这些更新操作
- 减少 DOM 操作次数， 提高应用的性能和响应速度

# pinia 在状态管理中的作用

- 响应式数据管理
- 模块化和可扩展性
- 类型安全和易用性
- 调试和开发工具集成

与 localStorage，全局对象的异同

- 用途
- 特性

# pinia 的核心原理

- 在 pinia 中状态时通过 vue 的 reactive 和 ref 来创建的
- pinia 允许定义多个 store，每个 store 时一个独立的模块
- pinia 的状态集中存储在一个相适应对象中，这个对象包含了所有 store 的状态

与 vuex 对比

- 弃用了 mutations
- 无需创建复杂的包装器来支持 typescript
- 无需动态添加 Store
- 不再有嵌套结构的模块
- 不再有可命名的模块
